#!/usr/bin/env tclsh

################################################################################
# VARIABLES
#
namespace eval tCalc {
  variable version   {0.2.5}
  variable safe      [interp create -safe]
  variable ontop     {false}
  variable resizable 0
  variable entry     {}
  variable hlist     [list]
  variable hindex    0
  variable precision 3
  variable error     {___tCalcError___}
}
# define new 'functions' for expr
namespace eval tcl::mathfunc {
  proc precision {number precision} {
    expr {double(round(10 ** $precision * $number)) / 10 ** $precision}
  }
  proc e {} {
    expr {exp(1)}
  }
  proc p {} {
    expr {acos(-1)}
  }
  proc sind {x} {
    set pi [expr {acos(-1)}]
    expr {sin($x * ($pi / 180))}
  }
  proc cosd {x} {
    set pi [expr {acos(-1)}]
    expr {cos($x * ($pi / 180))}
  }
  proc tand {x} {
    set pi [expr {acos(-1)}]
    expr {tan($x * ($pi / 180))}
  }
  proc asind {x} {
    set pi [expr {acos(-1)}]
    set x [expr {asin($x)}]
    expr {$x * (180 / $pi)}
  }
  proc acosd {x} {
    set pi [expr {acos(-1)}]
    set x [expr {acos($x)}]
    expr {$x * (180 / $pi)}
  }
  proc atand {x} {
    set pi [expr {acos(-1)}]
    set x [expr {atan($x)}]
    expr {$x * (180 / $pi)}
  }
}

# teach safe interpreter the new proc/functions
foreach trig {p e sind asind cosd acosd tand atand} {
  set trig [string cat "tcl::mathfunc::" $trig]
  $tCalc::safe alias $trig $trig
}

# helper function to evaluate with safe interpreter
proc tCalc::Evaluate {args} {
  set expression [string map {/ *1.0/} [join $args]]
  try {
    $tCalc::safe eval "expr $expression"
  } on error msg {
    puts stderr [lindex [split $msg "\n"] 0]
    set result $tCalc::error
  } on ok result {
    # round to user defined decimal points
    set result [expr {precision($result,$tCalc::precision)}]
    # avoid printing extra decimal zeros
    set result0 [expr {round($result)}]
    if {$result0 == $result} {
      set result $result0
    }
  } finally {
    return $result
  }
}

################################################################################
# COMMAND LINE
#
# if there are command line arguments, show result in terminal and exit
if {$::argc > 0} {
  set result [tCalc::Evaluate $::argv]
  if {$result eq $tCalc::error} {
    exit 255
  } else {
    puts stdout $result
    exit 0
  }
}
# else, start GUI
package require Tk

################################################################################
# PROCEDURES
#
proc tCalc::History {entry} {
  incr tCalc::hindex -1
  if {$tCalc::hindex < 0} {
    set tCalc::hindex [expr {[llength $tCalc::hlist] -1}]
  }
  set tCalc::entry [lindex $tCalc::hlist $tCalc::hindex]
  $entry xview end
  $entry icursor end
}

proc tCalc::Clear {entry} {
  set tCalc::entry ""
  $entry configure -style valid.TCombobox
}

proc tCalc::Result {entry} {
  if {$tCalc::entry ni $tCalc::hlist} {
    lappend tCalc::hlist $tCalc::entry
  }
  set tCalc::hindex [llength $tCalc::hlist]
  set result [tCalc::Evaluate $tCalc::entry]
  if {$result eq $tCalc::error} {
    $entry configure -style error.TCombobox
  } else {
    set tCalc::entry $result
    $entry configure -style valid.TCombobox
  }
  $entry xview end
  $entry icursor end
}

proc tCalc::Button {entry key} {
  $entry insert insert $key
}

proc tCalc::About {version} {
  tk_messageBox -title "About tCalc" -icon info -type ok -parent . \
    -message "tCalc $version" -detail \
{A simple calculator,
written in core Tcl/Tk.

MIT License

Copyright Â© Thanos Zygouris
<athanasios.zygouris@gmail.com>}
}

################################################################################
# MAIN MENU
#
proc tCalc::Menu {} {
  option add *tearOff false
  menu .menu
    .menu add command -label "About tCalc..." -underline 0 \
      -accelerator "F1" -command {tCalc::About $tCalc::version}
    .menu add separator
    .menu add checkbutton -label "On Top" -underline 3 \
      -accelerator "F2" \
      -variable tCalc::ontop -onvalue "true" -offvalue "false" \
      -command {wm attributes . -topmost $tCalc::ontop}
    .menu add checkbutton -label "Resizable" -underline 4 \
      -variable tCalc::resizable -onvalue 1 -offvalue 0 \
      -command {wm resizable . $tCalc::resizable 0}
    .menu add separator
    .menu add command -label "Cut" \
      -underline 2 -accelerator "Ctrl+X" \
      -command {event generate .entry <<Cut>>}
    .menu add command -label "Copy" \
      -underline 0 -accelerator "Ctrl+C" \
      -command {event generate .entry <<Copy>>}
    .menu add command -label "Paste" \
      -underline 0 -accelerator "Ctrl+V" \
      -command {event generate .entry <<Paste>>}
    .menu add separator
    .menu add cascade -label "Precision" -underline 1 \
      -menu [menu .menu.precision]
      for {set i 0} {$i <= 15} {incr i} {
        .menu.precision add radiobutton -label $i \
          -variable tCalc::precision -value $i
      }
    .menu add separator
    .menu add command -label "Exit" \
      -underline 1 -accelerator "Ctrl+Q" \
      -command {exit}
}

################################################################################
# WIDGETS
#
proc tCalc::Widgets {} {
  ttk::style configure valid.TCombobox -fieldbackground white
  ttk::style configure error.TCombobox -fieldbackground red

  ttk::combobox .entry -justify right -style valid.TCombobox \
    -textvariable tCalc::entry -values $tCalc::hlist \
    -postcommand {.entry configure -values $tCalc::hlist}
  grid .entry -columnspan 5 -sticky we -padx 1 -pady 1
  grid columnconfigure . .entry -weight 1

  set calc_buttons {
    {7 8 9 ( )}
    {4 5 6 * /}
    {1 2 3 + -}
    {C 0 . =}
  }
  set i 0
  set buttons [list]
  foreach row $calc_buttons {
    foreach key $row {
      switch -- $key {
        =       {set command [list tCalc::Result .entry]}
        C       {set command [list tCalc::Clear .entry]}
        default {set command [list tCalc::Button .entry $key]}
      }
      lappend buttons [tk::button ".[incr i]" -text $key -takefocus 0 \
        -command $command]
    }
    grid {*}$buttons -sticky we -padx 1 -pady 1
  }
  grid .$i -columnspan 2
}

################################################################################
# BINDINGS
#
proc tCalc::Bindings {} {
  bind all <3>         {tk_popup .menu %X %Y}
  bind all <F1>        {.menu invoke "About tCalc..."}
  bind all <F2>        {.menu invoke "On Top"}
  bind all <KP_Enter>  {event generate %W <Return>}

  bind .entry <Up>        {tCalc::History %W}
  bind .entry <Return>    {tCalc::Result %W}
  bind .entry <Escape>    {tCalc::Clear %W}
  bind .entry <Control-q> {exit}
  bind .entry <Control-a> {event generate %W <Tab>}
  bind .entry <<ComboboxSelected>> {%W selection clear}
}

################################################################################
# MAIN PROGRAM
#
tCalc::Menu
tCalc::Widgets
tCalc::Bindings
focus .entry

wm title     . "tCalc"
wm minsize   . 100 100
wm resizable . $tCalc::resizable 0
wm protocol  . WM_DELETE_WINDOW {exit}
